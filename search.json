[{"title":"C++的存储空间和编译过程","url":"/2024/11/18/C-%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","content":"存储空间在C++中，内存存储通常分为以下五个区域：\n1、代码区：\n存储程序的执行代码，这部分区域是共享的，只读的，并且在程序执行期间并不会更改。例如当你编辑一个C++程序时，所有的函数定义，控制结构等都会被变成机器指令，然后存到代码区里面\n\n2、全局、静态存储区\n存储全局变量和静态变量的内存区域，这些变量在整个程序的执行期间都会存在，只不过他们的可见性与生命周期取决于声明它们的作用域\n\n3、栈区\n存储局部变量，函数参数，返回地址等的内存区域，它的特点是先进后出用于存储函数调用和自然变量\n\n4、堆区\n在C++中，我们程序员通过动态内存分配函数（new函数和malloc函数）分配的内存空间，在开辟之后必须手动释放，以免出现内存泄漏和野指针的问题（内存泄漏是指开辟内存没有手动回收，野指针是指使用已经被手动回收的指针）\n\n5、常量区\n常量区一般是存储字符串常量和const修饰的数据，它代表这部分数据仅仅是可读的，程序员并不能对它们进行修改\n\n编译过程 C++程序的编译是一个相对复杂并且有序的过程，它涉及到将高级语言（C++）转换为机器可以识别的低级指令。在这个过程中，通常会生成.i(预处理文件)、.s(汇编文件)、.o(目标文件或对象文件)。以下是这个过程的详细解释\n1、预处理\n输入：C++源代码\n处理：预处理器读取源代码文件，并对其进行宏展开、条件编译、文件包含等操作\n输出：生成处理后的文件，通常带有.i后缀\n\n2、编译\n输入：预处理后的文件\n处理：编辑器将预处理后的源代码或文件转为汇编语言代码。这个步骤是编译的核心，编译器需要执行词法分析、语法分析、语义分析、中间代码生成、代码优化等任务\n输出：生成汇编文件，通常带有.s后缀\n\n3、汇编\n输入：汇编文件\n处理：汇编器将汇编语言代码转化为机器代码(只有0和1组成的文件)但是这些指令仍然是针对特定架构的，尚未被来凝结的可执行文件\n输出：生成目标文件，通常带有.o、.obj、.out等后缀\n\n4、链接\n输入：1个或多个目标文件以及可能需要的库文件\n处理：在这个过程中，链接器将目标文件和库文件合并成一个可执行文件或库文件。在这个过程中，链接器会解决外部符号引用(即函数和变量的调用)，并将它们链接到正确的地址\n输出： 可执行文件.exe\n\n","categories":["C++"],"tags":["软件"]},{"title":"使用Hexo安装博客，发现npm淘宝镜像源不生效的问题","url":"/2024/11/17/%E4%BD%BF%E7%94%A8Hexo%E5%AE%89%E8%A3%85%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%8F%91%E7%8E%B0npm%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/","content":"近期使用Hexo框架搭建博客的时候，发现使用npm下载淘宝镜像源总是失败，最后发现是淘宝更换了镜像源\n具体原因是：原NPM淘宝域名证书过期提醒：npm.taobao.org和registry.npm.taobao.org旧域名于2021年官方公告域名更换事件，已于2022年05月31日零时起停止服务，域名HTTPS证书于2024年1月22日正式到期，不可再用。若有前端工程仍使用旧域名镜像源，会导致编译失败或超时，影响功能迭代上线。为避免受到严重影响，请尽快将代码或流水线中配置的镜像源修改为以下任意源：x-repo(推荐)：http://x-repo.haier.net/repository/npm-public/；淘宝的新域名：https://registry.npmmirror.com/\n简单来说就是淘宝更换镜像源了。\n解决方案：使用npm执行以下命令即可\nnpm config set registry https://registry.npmmirror.com","categories":["搭建博客"],"tags":["软件"]},{"title":"医院his系统","url":"/2024/12/26/%E5%8C%BB%E9%99%A2his%E7%B3%BB%E7%BB%9F/","content":"一、基础信息维护药品信息药品信息的维护一般需要记录药品的名称，药品的生产企业，药品的剂量，药品的剂型，药品是否进行皮试，药品的采购价格，药品的出售价格，药品是否进行拆零，药品拆零后的出售单价，药品的加价率，药品的包装单位，药品的最小包装单位等信息；如果接入医保网，则还需要提供医保编码与追溯码等信息\n中药信息维护中药一般不需要提供具体的生产企业，只需要提供生产省份即可；中药的剂量与单位都已g为标准，中药的剂型都为中药饮片\n西药、中成药信息维护跟中药相比，西药与中成药记录的信息更为详细，也更为麻烦\n1、西药的生产企业需要明确到生产公司\n2、西药的剂量要进行确认，例如250ml的氯化钠注射液与100ml的氯化钠注射液就是两个药品\n3、西药的剂型需要进行确认，例如丸剂、注射液、片剂等剂型，药品名相同但是剂型不同，两者也就不是一个药品\n4、注射液药品还需要确认病人是否对其过敏，因此在开具处方之前需要先对病人进行皮试\n5、西药还需要确认药品的包装，药品是否拆零，拆零后的价格又是多少，拆零后的包装又是什么\n医保编码追溯码诊疗项目信息医院的每个诊疗项目都有严格的收费标准，医院的等级不同，它的收费标准也不相同，一般来说医院的等级越低，它的收费价格也就越低；而且，一个省内的每个市所规定的收费标准也都各不相同，所以医院的诊疗项目信息一定要确认好，每个诊疗项目的收费标准不能超过市级所规定的收费标准，要不然当地的政府会罚医院的钱\n医疗耗材信息医疗耗材信息也跟诊疗项目信息一样，耗材的收费标准也不能超过市级所规定的收费标准\n二、门诊系统流程图\n首先病人看病需要先挂号，挂号之后找到相应的医生看病，医生根据病人的情况开出相应的单子，病人再到收费处进行缴费，收费处收完费用之后打印出收费项目给病人，如果收费项目里面有中药处方或西药处方，则病人就到药房去领取中药或西药；如果收费项目里面有化验单，则病人就到检验科做化验项目并在检验科领取化验单；如果收费项目有DR或CT，则病人就到放射科拍片，之后在放射科领取DR或CT片子；如果收费项目有彩超，则病人在彩超室做相应部位的彩超并领取彩超单子\n药房、药库设置挂号设置医生开方设置收费设置取药开化验单开DR、CT单开B超，超声单三、住院系统"},{"title":"网络聊天项目(1)使用QT创建聊天室客户端","url":"/2024/11/20/%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE(1)-%E4%BD%BF%E7%94%A8QT%E5%88%9B%E5%BB%BA%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%AE%A2%E6%88%B7%E7%AB%AF/","content":"Note： 此项目原博客地址https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2eIZbBf2pkVGQG1oPdRLDtTDLo0\n1、创建项目首先使用QT软件创建Qt Widgets Application,生成的基类使用QMainWindow\n\n2、添加资源文件并更换图标首先将准备的图片文件添加到res文件夹下，然后将res文件夹放下项目根目录下；然后在Qt软件中点中项目名称，选择添加新文件，选择Qt Resource Files,添加Qt的资源文件，名字设为rc，添加成功后右键rc.qrc选择添加现有文件，然后选中res文件夹下的所有图片，这样res文件夹下的所有图片资源都导入到项目里面了。\n然后将QMainWindow的界面长宽改为300x500\n\n之后修改项目左上角的图标，在QMainWindow的界面找到windowIcon，选择添加res文件下的ICNO.ico\n\n修改项目左上面的标题，将MainWindow修改为Chat,在QMainWindow的构造函数添加以下代码即可\nsetWindowTitle(&quot;Chat&quot;);\n3、添加登录页面右键项目名称并选择添加新项目，点击Qt设计师界面类\n\n选择Dialog Without Buttons\n\n将名字起为LoginDialog,创建完成后点击ui界面并将ui界面修改为以下布局：\n\n在QMainWindow的类里添加LoginDialog的指针成员，并在QMainWindow构造函数里面设置为中心部件\n_login_dialog = new LoginInDialog();setCentralWidget(_login_dialog);_login_dialog-&gt;show();\n4、添加样式表在项目的根目录下创建一个名为style的文件夹，打开style文件夹建立一个.text文件，将这个.text文件名称改为stylesheet.qss，然后右键点击Qt项目中的rc.qrc，选择添加现有文件，选择刚刚创建的style文件夹即可，这样stylesheet.qss就被导入到项目中了\n打开stylesheet.qss并写下如下代码\nQDialog#LoginInDialog&#123;  background-color:rgb(255,255,255)&#125;\n这样LoginInDialog界面的背景就被美化成白色了\n然后在主函数main里面添加以下代码用来启动qss文件\nint main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    QFile qss(&quot;:/style/stylesheet.qss&quot;);    if(qss.open(QFile::ReadOnly))&#123;        qDebug(&quot;open success!&quot;);        QString style = QLatin1String(qss.readAll());        a.setStyleSheet(style);        qss.close();    &#125;else&#123;        qDebug(&quot;open failed!&quot;);    &#125;    MainWindow w;    w.show();    return a.exec();&#125;\n5、添加注册页面跟添加登录页面的方式添加注册页面，将名字设置为RegisterDialog，添加完成之后打开注册页面的ui，将注册页面的ui修改成以下画面\n\n然后在注册页面的构造函数里面将code_lineedit和confirm_lineedit置为密码模式\nui-&gt;code_lineedit-&gt;setEchoMode(QLineEdit::Password);ui-&gt;confirm_lineedit-&gt;setEchoMode(QLineEdit::Password);\n\n我们在qss里面添加tips的样式，正确状态下tips里面的文字显示为绿色，错误状态下tips的文字显示为红色\n#tips[state = &#x27;normal&#x27;]&#123;  color: green;&#125;#tips[state = &#x27;error&#x27;]&#123;  color: red;&#125;\n\n然后我们来实现tips的刷新功能，这个刷新功能函数repolish打算做成全局函数来实现,因此我们添加global.cpp和global.h文件\nglobal.h文件的声明：\n#ifndef GLOBAL_H#define GLOBAL_H#include &lt;QWidget&gt;#include &lt;functional&gt;#include &quot;QStyle&quot;extern std::function&lt;void(QWidget*)&gt; repolish;#endif // GLOBAL_H\n\nglobal.cpp文件里repolish函数的实现：\nstd::function&lt;void(QWidget*)&gt; repolish=[](QWidget* w)&#123;    w-&gt;style()-&gt;unpolish(w);    w-&gt;style()-&gt;polish(w);&#125;;\n\n在RegisterDialog的构造函数里面添加tips的样式设置\nui-&gt;tips-&gt;setProperty(&quot;state&quot;, &quot;normal&quot;);repolish(ui-&gt;tips);\n\n接下来实现获取验证码的逻辑，在RegisterDialog.ui里面右键点击获取按钮，选择转到槽，在槽函数里面写下如下代码\n//使用正则表达式验证邮箱地址auto email=ui-&gt;email_lineedit-&gt;text();//邮箱地址的正则表达式QRegularExpression regex(R&quot;((\\w+)(\\.|_)?(\\w*)@(\\w+)(\\.(\\w+))+)&quot;);bool match = regex.match(email).hasMatch();if(match)&#123;    ShowTips(&quot;邮箱地址正确&quot;, true);    //发送Http请求发送验证码&#125;else&#123;    ShowTips(&quot;邮箱地址不正确&quot;, false);&#125;\n\n下面实现ShowTips函数，这个函数用来显示tips的文字和状态\nvoid RegisterDialog::ShowTips(QString str, bool b_ok)&#123;    if(b_ok)&#123;        ui-&gt;tips-&gt;setProperty(&quot;state&quot;, &quot;normal&quot;);    &#125;    else&#123;        ui-&gt;tips-&gt;setProperty(&quot;state&quot;, &quot;error&quot;);    &#125;    ui-&gt;tips-&gt;setText(str);    repolish(ui-&gt;tips);&#125;\n\n6、添加单例类我们编写网络通讯需要确保一个类只生成一个实例，所以我们编写一个单例模板类，之后的网络通讯类都继承这个单例类\n#include &lt;mutex&gt;#include &lt;memory&gt;#include &lt;iostream&gt;#include &quot;QDebug&quot;template &lt;typename T&gt;class SingleTon&#123;protected:   SingleTon() = default;   SingleTon(const SingleTon&lt;T&gt;&amp;) = delete;   SingleTon&amp; operator = (const SingleTon&lt;T&gt;&amp;) = delete;   static std::shared_ptr&lt;T&gt; _instance;public:   static std::shared_ptr&lt;T&gt; GetInstance()&#123;       static std::once_flag _flag;       std::call_once(_flag,[&amp;]()&#123;           _instance = std::shared_ptr&lt;T&gt;(new T);       &#125;);       return _instance;   &#125;   void PrintAdress()&#123;       std::cout&lt;&lt; _instance.get() &lt;&lt;std::endl;   &#125;&#125;;template &lt;typename T&gt;std::shared_ptr&lt;T&gt; SingleTon&lt;T&gt;::_instance = nullptr;\n\n7、添加Http管理类Http管理类主要用于管理HTTP接收发送等请求，首先我们需要在pro文件里面添加网络库\nQT  +=  core gui network\n\n在global.h里面添加一些Http管理类用到的头文件\n#include &lt;QByteArray&gt;#include &lt;QNetworkRequest&gt;#include &lt;QNetworkReply&gt;#include &lt;qDebug&gt;#include &lt;QString&gt;#include &lt;QUrl&gt;#include &lt;QObject&gt;#include &lt;QNetworkAccessManager&gt;#include &lt;memory&gt;#include &lt;QJsonObject&gt;#include &lt;QJsonDocument&gt;#include &lt;QMap&gt;\n\n添加httpMgr.cpp和httpMgr.h，httpMgr.h头文件如下\n#ifndef HTTPMGR_H#define HTTPMGR_H#include &quot;singleton.h&quot;#include &quot;global.h&quot;class HttpMgr: public QObject,public SingleTon&lt;HttpMgr&gt;, public std::enable_shared_from_this&lt;HttpMgr&gt;&#123;    Q_OBJECT    friend class SingleTon&lt;HttpMgr&gt;;public:    ~HttpMgr();    void PostHttpRequest(ReqID id, Modules modules, QUrl url, QJsonObject json);signals:    void SignalHttpFinished(ReqID id, Modules modules, ErrorCode ec_code, QString res);    //    void SignalRegisterFinished(ReqID id, ErrorCode ec_code, QString res);private slots:    void SlotHttpFished(ReqID id, Modules modules, ErrorCode ec_code, QString res);private:    HttpMgr();    QNetworkAccessManager  _manager;&#125;;#endif // HTTPMGR_H\n\nPostHttpRequest函数用来接收HTTP发送过来的消息，参数id和modules用来区分HTTP信息的类型，url是请求的地址，json是请求的数据\n我们在global.h里面定义ReqID枚举类型\nenum ReqID&#123;    ID_GET_VARIFY_CODE = 1001,    ID_REGISTER_USER = 1002&#125;\n\nReqID有两个作用，一个作用是定位接收的是哪一部份数据；第二个作用是存储数据的key值使用，ReqID&#x3D;1001时，说明此时处于注册状态，我们需要将ReqID和验证码存入到map里，ReqID就作为验证码的key值使用；同理，当ReqID&#x3D;1002时，ReqID就作为密码的key值所使用\n在global.h里面定义ErrorCode\nenum ErrorCode&#123;    SUCESS = 0,    ERROR_JSON = 1,    ERROR_NETWORK = 2&#125;;\n\nErrorCode是错误的类型，用于帮助定位项目运行过程中在哪一部分出现问题\n在global.h里面定义Modules\nenum Modules&#123;    REGISTER_MOD = 0,&#125;;\n\nModules也是用来定位接收的是哪一部分数据，用来说明项目此时处于的状态，目前只将注册状态设为0，但之后还会有登录状态和忘记密码的状态\n在PostHttpRequest函数里面首先发送Post请求然后收到回复并解析，无论解析的数据如何都会发送SignalHttpFinished信号，然后数据传输到槽函数SlotHttpFished里面，槽函数SlotHttpFished再次发送信号SignalRegisterFinished，接收信号的槽函数SlotRegisterFinished被定义于RegisterDialog类里面\n简单来讲，RegisterDialog类里面的函数调用HttpMgr类的函数发送HTTP信息，HttpMgr类的函数将接收的信息传送回RegisterDialog类里面的函数，数据的解析是在RegisterDialog类里进行，HttpMgr类只负责数据的发送和接收\nPostHttpRequest函数的实现如下\nvoid HttpMgr::PostHttpRequest(ReqID id, Modules modules, QUrl url, QJsonObject json)&#123;    QByteArray data = QJsonDocument(json).toJson();    QNetworkRequest request(url);    request.setHeader(QNetworkRequest::ContentTypeHeader, &quot;application/json&quot;);    request.setHeader(QNetworkRequest::ContentLengthHeader,QByteArray::number(data.length()));    auto self = shared_from_this();    //发送reques数据    QNetworkReply* reply =  _manager.post(request, data);    //接受reply数据    QObject::connect(reply, &amp;QNetworkReply::finished, [reply,  self, id, modules]()&#123;        //发送错误        if(reply-&gt;error() != QNetworkReply::NoError)&#123;            qDebug()&lt;&lt;reply-&gt;errorString();            //发送信号说明数据传输错误            emit self-&gt;SignalHttpFinished(id, modules, ErrorCode::ERROR_NETWORK, &quot;&quot;);            reply-&gt;deleteLater();            return;        &#125;        //发送信号说明数据已经传输完成        QString res = reply-&gt;readAll();        emit self-&gt;SignalHttpFinished(id, modules, ErrorCode::SUCESS, res);        reply-&gt;deleteLater();        return;    &#125;);&#125;\n\n槽函数SlotHttpFished的实现\nvoid HttpMgr::SlotHttpFished(ReqID id, Modules modules, ErrorCode ec_code, QString res)&#123;    if(modules == Modules::REGISTER_MOD)&#123;        emit SignalRegisterFinished(id, ec_code, res);    &#125;&#125;\n\n在HttpMgr的构造函数里面将信号SignalHttpFinished与槽函数SlotHttpFished连接\nconnect(this, &amp;HttpMgr::SignalHttpFinished, this, &amp;HttpMgr::SlotHttpFished);\n\n在RegisterDialog的构造函数里面将信号SignalRegisterFinished和槽函数SlotRegisterFinished连接\nconnect(HttpMgr::GetInstance().get(), &amp;HttpMgr::SignalRegisterFinished, this, &amp;RegisterDialog::SlotRegisterFinished);\n\n然后实现槽函数SlotRegisterFinished\nvoid RegisterDialog::SlotRegisterFinished(ReqID id, ErrorCode ec_code, QString res)&#123;    if(ec_code != ErrorCode::SUCESS)&#123;        ShowTips(&quot;网络请求错误&quot;, false);        return;    &#125;    //接收数据正常    else&#123;        QJsonDocument jsonDoc = QJsonDocument::fromJson(res.toUtf8());        if(jsonDoc.isNull())&#123;            ShowTips(&quot;JSON解析错误&quot;, false);            return;        &#125;        if(jsonDoc.isObject())&#123;            ShowTips(&quot;JSON解析错误&quot;, false);            return;        &#125;        //处理相应请求        _handlers[id](jsonDoc.object());        return;    &#125;&#125;\n\n8、添加注册信息处理我们需要对注册的信息进行处理，在RegisterDialog类的私有成员进行声明\n// _handlers处理注册ID和验证码信息QMap&lt;ReqID, std::function&lt;void(const QJsonObject&amp;)&gt;&gt; _handlers;\n\n对于注册信息的定义与声明\nvoid RegisterDialog::InitHttpHandlers()&#123;    _handlers.insert(ReqID::ID_GET_VARIFY_CODE, [this](QJsonObject jsonobj)&#123;        int error = jsonobj[&quot;error&quot;].toInt();        if(error != ErrorCode::SUCESS)&#123;            ShowTips(&quot;参数错误&quot;, false);            true;        &#125;        auto email = jsonobj[&quot;email&quot;].toString();        ShowTips(&quot;验证码已经发送到邮箱,请注意查收&quot;, true);    &#125;);&#125;\n\n在槽函数SlotRegisterFinished里面添加根据id调用函数处理对应逻辑\nvoid RegisterDialog::SlotRegisterFinished(ReqID id, ErrorCode ec_code, QString res)&#123;    if(ec_code != ErrorCode::SUCESS)&#123;        ShowTips(&quot;网络请求错误&quot;, false);        return;    &#125;    //接收数据正常    else&#123;        //前面逻辑省略...        //处理相应请求        _handlers[id](jsonDoc.object());        return;    &#125;&#125;","categories":["C++网络聊天项目"],"tags":["软件"]},{"title":"URL详解","url":"/2024/11/27/URL%E8%AF%A6%E8%A7%A3/","content":"前言 Internet上的每一个网页都具有一个统一的标识，通常称为URL（Uniform Resource Locator, 统一资源定位器）。它是www的统一资源定位标志，简单地说URL就是web地址，俗称“网址”。\nURLURL是对互联网上得到的资源的位置和访问方法的一种简洁表示，是互联网上标准资源的地址。URL它具有全球唯一性，正确的URL应该是可以通过浏览器打开此网页的，但如果您访问外网，会提示网页无法打开，这并不能说明这个URL是错误的。只不过在国内不能访问而已。\n访问百度网站时，你的浏览器上就会显示http://www.baidu.com，如下图：\n\nURL由三部分组成：资源类型、存放资源的主机域名、资源文件名。\nURL的一般语法格式为：\nprotocol :// hostname[:port] / path / [;parameters][?query]#fragment\n\n格式说明:\nprotocol（协议）指定使用的传输协议，最常用的HTTP协议，它是目前WWW中应用最广的协议。\n下面列出protocol属性常见的名称：\nhttp 通过 HTTP 访问该资源。 格式 HTTP://https 通过安全的 HTTPS 访问该资源。 格式 HTTPS://\n\n一般来说，https开头的URL要比http开头的更安全，因为这样的URL传输信息是采用了加密技术。如果https是网银服务，以上SSL安全隧道成功建立会要求输入账户信息，账号信息是在安全隧道里传输，所有传输的内容都经过加密，所以不会泄密！\nhostname（主机名）\n是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password@hostname）。\nport（端口号）\nHTTP缺省工作在TCP协议80端口，用户访问网站http:&#x2F;&#x2F; 打头的都是标准HTTP服务。HTTPS缺省工作在TCP协议443端口。\npath（路径）\n由零或多个“&#x2F;”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。\nparameters（参数）\n这是用于指定特殊参数的可选项。\nquery(查询)\n可选，用于给动态网页（如使用CGI、ISAPI、PHP&#x2F;JSP&#x2F;ASP&#x2F;ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&amp;”符号隔开，每个参数的名和值用“&#x3D;”符号隔开。\nfragment（信息片断）\n信息片断，字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。\n注意，Windows 主机不区分 URL 大小写，但是，Unix&#x2F;Linux 主机区分大小写。\n 参考文章：https://blog.csdn.net/chen1415886044/article/details/103914255\n","categories":["C++网络基本知识"],"tags":["软件"]},{"title":"使用Hexo更换主题后出现问题的解决方法","url":"/2024/11/17/%E4%BD%BF%E7%94%A8Hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E5%90%8E%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"前段时间使用Hexo成功搭建了网站，后来更改Hexo主题后重新启动了服务器，但是界面却出现了以下字符：\nextends includes/layout.pug block content include includes/recent-posts.pug include includes/partial\n具体原因后来才发现更改主题还需要使用npm安装以下两个插件才行： hexo-renderer-pug和hexo-renderer-stylus\n解决方案：我们使用npm执行以下命令即可\nnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\n","categories":["搭建博客"],"tags":["软件"]},{"title":"使用markdown添加图片不显示问题的解决方法","url":"/2024/11/23/%E4%BD%BF%E7%94%A8markdown%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"问题描述在这几天，我尝试使用markdown添加图片，但是图片却显示不出来。\n这是我当时使用markdown写下的添加图片的格式：\n![Wide_And_Length](/image/使用QT创建聊天室客户端/QMainWindow长宽大小.png)\n这是当时预览的图片显示\n\n我的存储图片的文件夹跟md文件存储在同一目录下，如图所示\n\n然后我尝试了将图片的路径先返回到上一级的目录下，然后再添加图片路径，这时候在markdown文档预览的时候出现了图片，但是当我将文章发布到了GitHub之后却发现图片依旧显示不出来\n此时添加图片的格式\n![Wide_And_Length](../_posts/image/使用QT创建聊天室客户端/QMainWindow长宽大小.png)\n\nmarkdown文档预览效果\n打开博客实际效果\n\n解决方法首先在博客仓库下选择添加新的文件\n\n然后选择添加新的分支\n\n将图片添加到这个分支里面\n\n右键点击图片选择复制图片地址，将地址复制到之前的图片路径上\n\n这样图片就能显示出来了\n参考文章https://www.jianshu.com/p/c7618a53454f\n","categories":["搭建博客"],"tags":["软件"]},{"title":"网络聊天项目(2)-VisualStudio配置boost与json","url":"/2024/11/24/%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE(2)-VisualStudio%E9%85%8D%E7%BD%AEboost%E4%B8%8Ejson/","content":"Note： 此项目原博客地址https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2eIZxNzngJYIRWlBEXDJyVdk9Lb\nBoost库安装打开Boost库官网https://www.boost.org/,下载boost库文件安装包\n解压boost库文件后，点击booststrap.bat生成b2.exe执行文件\n\n生成b2.exe后，点击他并输入以下命令\n.\\b2.exe install --toolset=msvc-14.3 --build-type=complete --prefix=&quot;D:\\cppsoft\\boost_1_81_0&quot; link=static runtime-link=shared threading=multi debug release\n\n先来解释一下各个参数的含义\n\ninstall代表可以更改为stage，stage只生成库(lib和dll)，install还会生成包含头文件的include目录。一般来说用stage足够了我们将生成的lib和下载的源码包的include头文件放到项目要用到的地方即可\n\ntoolset指定编译器，gcc是编译生成Linux用的库，msvc是用来编译生成Windows用的库，msvc后面的-14.3代表了我使用的Visual Studio是2022版本，这里的数字一定要与Visual Studio的版本相对应\n\n如果选择的是install命令，指定生成的库文件夹要用–prefix，如果使用的是stage命令，需要用到–stagedir来指定\n\nlink表示要生成静态库还是动态库，static表示生成lib库，shared表示生成dll库\n\nruntime-link表示用于指定运行时链接方式为静态库还是动态库，指定为static就是MT模式，指定shared就是MD模式。MD和MT是微软Visual C++编辑器的选项，用于指定运行库时的链接方式，这两个选项有以下两个区别：\n1、MD：表示使用多线程DLL(Dynamic Link Library)版本运行时的库。这意味着你的应用程序将使用动态链接的运行时库(MSVCRT.dll)，这样的设置可以减少最终可执行文件的大小，并允许运行程序与其他使用相同运行库版本的程序共享代码和数据\n2、MT：表示使用多线程静态库(Static Library)版本时运行的库。这意味着所有的运行函数都将被静态链接到应用程序里面，使得应用程序不在依赖于动态链接时的运行库。这样可以确保应用程序在没有额外依赖的情况下独立运行，但可能会导致最终可执行文件体积的增大\n\n\n一句话简化上边的含义，就是我们生成的lib库，运行时采用MD加载模式\n下面是编辑界面\n\n标注的就是运行命令后生成的目录和文件\n\n接下来我们配置Boost\n配置Boost库打开Visual Studio创建项目，右键点击项目选择属性，点开VC++目录,选择包含目录，添加路径D:\\WorkSoft\\Code\\Three-part_libraries\\Boost\\boost_1_85_0\n\n然后选择库目录，添加路径D:\\WorkSoft\\Code\\Three-part_libraries\\Boost\\boost_1_85_0\\lib\n\n配置包含目录和库目录的路径都是自己电脑上boost文件的目录\n接下来写个代码测试一下\n#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;boost/lexical_cast.hpp&quot;int main()&#123;    using namespace std;    cout &lt;&lt; &quot;Enter your weight: &quot;;    float weight;    cin &gt;&gt; weight;    string gain = &quot;A 10% increase raises &quot;;    string wt = boost::lexical_cast&lt;string&gt; (weight);    gain = gain + wt + &quot; to &quot;;      // string operator()    weight = 1.1 * weight;    gain = gain + boost::lexical_cast&lt;string&gt;(weight) + &quot;.&quot;;    cout &lt;&lt; gain &lt;&lt; endl;    system(&quot;pause&quot;);    return 0;&#125;\n\n运行成功，就会弹出以下界面\n\n配置jsoncpp因为客户端与服务器之间的通讯一般都使用jsoncpp进行数据加密，所以我们也使用jsoncpp，首先从官网https://github.com/open-source-parsers/jsoncpp下载相应的压缩包，解压压缩包后生成以下文件\n\n点击makefiles文件\n\n找到jsoncpp.sln文件，用Visual Studio打开，之后会出现单项升级提示，点击确定\n\n找到项目里的lib_json，选择用X64位的编译平台进行编译，将debug与release两个版本都编译一下\n\n右键lib_json选择属性，打开C&#x2F;C++再选择代码生成，之后在右侧选择运行库，选择MDd版本\n\n编译生成后，在makefiles文件下就会生成x64文件夹\n\n接下来我在D:\\WorkSoft\\Code\\Three-part_libraries\\Json这个目录下创建一个json文件夹，在其内部闯将include和lib两个文件夹\n\n将jsoncpp-src-0.5.0源码文件夹下include文件夹里的内容copy到libjson下的include文件夹内。\n将jsoncpp-src-0.5.0源码文件夹下x64位debug文件夹和Release文件夹下生成的库copy到libjson下的lib文件夹内。\n\n接下来，我们需要在项目属性中配置jsoncpp，同配置boost一样，先配置包含目录,添加路径D:\\WorkSoft\\Code\\Three-part_libraries\\Json\\json\\include\n\n之后，再配置库目录，添加路径\n\n另外我们还需要设置链接器-&gt;输入-&gt;附加依赖项里设置json_vc71_libmtd.lib\n\n之后，我们写个代码测试一下json库的安装情况\n#include &lt;iostream&gt;#include &lt;json/json.h&gt;#include &lt;json/value.h&gt;#include &lt;json/reader.h&gt;int main()&#123;    Json::Value root;    root[&quot;id&quot;] = 1001;    root[&quot;data&quot;] = &quot;hello world&quot;;    std::string request = root.toStyledString();    std::cout &lt;&lt; &quot;request is &quot; &lt;&lt; request &lt;&lt; std::endl;    Json::Value root2;    Json::Reader reader;    reader.parse(request, root2);    std::cout &lt;&lt; &quot;msg id is &quot; &lt;&lt; root2[&quot;id&quot;] &lt;&lt; &quot; msg is &quot; &lt;&lt; root2[&quot;data&quot;] &lt;&lt; std::endl;&#125;\n\n代码的输出如下：\n\n","categories":["C++网络聊天项目"],"tags":["软件"]},{"title":"使用beast网路库实现Http通讯","url":"/2024/12/02/%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE(3)-%E4%BD%BF%E7%94%A8boost%E7%BD%91%E8%B7%AF%E5%BA%93%E5%AE%9E%E7%8E%B0Http%E9%80%9A%E8%AE%AF/","content":"Note： 此项目原博客地址https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2eIaI00hKJDhilXBVmIqPERpqXq\n代码整体思路与流程图流程图：\n\n整体思路：首先由Server类来接收客户端发送过来的信息，但是Server类并不对接收的信息进行具体处理，而是下发给HttpConnectionMgr类，让HttpConnectionMgr来判断接收的到底是GET信息还是POST信息，然后解析出URL，将URL传递给逻辑层LogicSystem类，通过JSON解析出邮箱，然后将相应的信息注入_response(回复的信息)中，然后返回HttpConnection类发送_response给客户端\n创建项目打开Visual stdidual,创建GateServer项目，选择控制台程序，创建完成后开始配置boost环境和json环境，如何配置boost与json在上篇文章已经介绍过了，这里就不多赘述\n创建ServerServer类用于接收客户端发送的数据，以下是Server类的声明\nclass Server: public std::enable_shared_from_this&lt;Server&gt;&#123;public:\tServer(boost::asio::io_context&amp; ioc, unsigned short&amp; port);\tvoid Start();private:\tboost::asio::io_context&amp; _io_context;\tboost::asio::ip::tcp::acceptor _acceptor;\tboost::asio::ip::tcp::socket _socket;\tunsigned short&amp; _port;&#125;;\n\nServer的类构造函数需要接受一个端口号，创建acceptor来接收新到来的链接，代码如下\nServer::Server(boost::asio::io_context&amp; ioc, unsigned short&amp; port)\t: _io_context(ioc), _socket(ioc), _port(port), _acceptor(ioc, boost::asio::ip::tcp::endpoint(boost::asio::ip::tcp::v4(), port)) &#123;&#125;\n\nStart函数是用来实现监听新链接，代码如下\nvoid Server::Start() &#123;\tauto self = shared_from_this();\t_acceptor.async_accept(_socket, [self](boost::beast::error_code ec) &#123;\t\ttry &#123;\t\t\t//服务器不能停止，所以出现错误也要继续监听\t\t\tif (ec) &#123;\t\t\t\tself-&gt;Start();\t\t\t\treturn;\t\t\t&#125;\t\t\t//没有出现错误，所以创建HttpConnectinMgr类来管理HTTP连接\t\t\tstd::make_shared&lt;HttpConnectionMgr&gt;(std::move(self-&gt;_socket))-&gt;Start();\t\t\tself-&gt;Start();\t\t&#125;\t\tcatch (std::exception&amp; error) &#123;\t\t\tstd::cout &lt;&lt; &quot;Server start error, error is: &quot; &lt;&lt; error.what() &lt;&lt; std::endl;\t\t\tself-&gt;Start();\t\t&#125;\t\t&#125;);&#125;\n\n在Start函数内创建HttpConnectionMgr的智能指针，将_socket数据转移到HttpConnectionMgr管理，Server类里面原来的_socket就可以继续用来接收写链接\n创建const.h并将常用的头文件放进去，代码如下\n#pragma once#include &lt;boost/beast/http.hpp&gt;#include &lt;boost/beast.hpp&gt;#include &lt;boost/asio.hpp&gt;\n\n创建HttpConnectionMgr创建HttpConnectionMgr类，添加以下代码\nclass HttpConnectionMgr:public std::enable_shared_from_this&lt;HttpConnectionMgr&gt;&#123;\tfriend class LogicSystem;public:\tHttpConnectionMgr(boost::asio::ip::tcp::socket socket);\tvoid Start();private:\tvoid CheckDeadLine();\tvoid WriteResponse();\tvoid HandleRequest();\tboost::asio::ip::tcp::socket _socket;\tboost::beast::flat_buffer _buffer&#123; 8192 &#125;;\tboost::beast::http::request&lt;boost::beast::http::dynamic_body&gt; _request;\tboost::beast::http::response&lt;boost::beast::http::dynamic_body&gt; _response;\tboost::asio::steady_timer _deadline&#123; _socket.get_executor(), std::chrono::seconds(60) &#125;;&#125;;\n\n_buffer用来接收接收数据\n _request用来解析请求\n _response用来回复客户端\n _deadline用来检验请求是否超时\n 以下是类构造函数的实现  HttpConnectionMgr::HttpConnectionMgr(boost::asio::ip::tcp::socket socket): _socket(std::move(socket))&#123;&#125;\nStart()函数的实现  void HttpConnectionMgr::Start()&#123;\tauto self = shared_from_this();\tboost::beast::http::async_read(_socket, _buffer, _request, [self](boost::beast::error_code ec, std::size_t byte_transfered) &#123;\t\ttry &#123;\t\t\tif (ec) &#123;\t\t\t\tstd::cout &lt;&lt; &quot;Read Http is failed, error2 is: &quot; &lt;&lt; ec.what() &lt;&lt; std::endl;\t\t\t\treturn;\t\t\t&#125;\t\t\t//处理收到的数据\t\t\tboost::ignore_unused(byte_transfered);\t\t\tself-&gt;HandleRequest();\t\t\tself-&gt;CheckDeadLine();\t\t&#125;\t\tcatch (std::exception&amp; error) &#123;\t\t\tstd::cout &lt;&lt; &quot;Read Http is failed, error1 is: &quot; &lt;&lt; error.what() &lt;&lt; std::endl;\t\t&#125;\t\t&#125;);&#125;\n Start()函数用来接收客户端的信息，通过异步读的方式将客户端发送过来的信息存入到 _buffer和 _request里面\n 接下来我们实现HandleRequest()函数  void HttpConnectionMgr::HandleRequest() &#123;\t//设置版本\t_response.version(_request.version());\t//设置为短链接\t_response.keep_alive(false);\t//发送的是GET请求\tif (_request.method() == boost::beast::http::verb::get) &#123;\t\tbool sucess = LogicSystem::GetInstance()-&gt;HandleGet(_request.target(), shared_from_this());\t\tif (sucess) &#123;\t\t\t_response.result(boost::beast::http::status::ok);\t\t\t_response.set(boost::beast::http::field::server, &quot;GateServer&quot;);\t\t\tWriteResponse();\t\t\treturn;\t\t&#125;\t\telse &#123;\t\t\t_response.result(boost::beast::http::status::not_found);\t\t\t_response.set(boost::beast::http::field::content_type, &quot;text/plain&quot;);\t\t\tboost::beast::ostream(_response.body()) &lt;&lt; &quot;url not found\\r\\n&quot;;\t\t\tWriteResponse();\t\t\treturn;\t\t&#125;\t&#125;\t//发送的是POST请求&#125;\n收到数据之后，我们将GET请求的具体处理丢给LogicSystem类，在HttpConnectionMgr类里面只根据处理成功还是失败回应数据包给对方。\n创建LogicSystem为了保证程序的安全性，所以实现LogicSystem类我们采用单例模式\n单例类的实现\n#pragma once#include &lt;mutex&gt;#include &lt;memory&gt;#include &lt;iostream&gt;template &lt;typename T&gt;class SingleTon &#123;protected:\tSingleTon() = default;\tSingleTon(const SingleTon&lt;T&gt;&amp;) = delete;\tSingleTon&amp; operator=(const SingleTon&lt;T&gt;&amp;) = delete;\tstatic std::shared_ptr&lt;T&gt; _instance;public:\tstatic std::shared_ptr&lt;T&gt; GetInstance() &#123;\t\tstatic std::once_flag _flag;\t\tstd::call_once(_flag, [&amp;]() &#123;\t\t\t_instance = std::shared_ptr&lt;T&gt;(new T);\t\t\t&#125;);\t\treturn _instance;\t&#125;\tvoid PrintAddress() &#123;\t\tstd::cout &lt;&lt; _instance.get() &lt;&lt; std::endl;\t&#125;\t~SingleTon() &#123;\t\tstd::cout &lt;&lt; &quot;this singleton is destructed!&quot; &lt;&lt; std::endl;\t&#125;&#125;;template &lt;typename T&gt;std::shared_ptr&lt;T&gt; SingleTon&lt;T&gt;::_instance = nullptr;\n\n接下来实现LogicSystem单例类\n#pragma once#include &quot;SingleTon.h&quot;#include &lt;functional&gt;#include &lt;map&gt;#include &quot;const.h&quot;class HttpConnectionMgr;typedef std::function&lt;void(std::shared_ptr&lt;HttpConnectionMgr&gt;)&gt; HttpHandler;class LogicSystem:public SingleTon&lt;LogicSystem&gt;&#123;\tfriend class SingleTon&lt;LogicSystem&gt;;public:\t~LogicSystem();\tbool HandleGet(std::string url, std::shared_ptr&lt;HttpConnectionMgr&gt; connection);\tvoid RegsiterGet(std::string url, HttpHandler handler);private:\tLogicSystem();\tstd::map&lt;std::string, HttpHandler&gt; _post_handler;\tstd::map&lt;std::string, HttpHandler&gt; _get_handler;&#125;;\n\n_post_handler是POST请求的回调函数的map，_get_handler是GET请求的回调函数的map，key为路由，value为回调函数，只不过这里将回调函数是使用std::function包装成HttpHandler\n接下来实现LogicSystem类的构造函数\nLogicSystem::LogicSystem()&#123;\t//处理GET请求\tRegsiterGet(&quot;/get_test&quot;, [](std::shared_ptr&lt;HttpConnectionMgr&gt; connection) &#123;\t\tboost::beast::ostream(connection-&gt;_response.body()) &lt;&lt; &quot;recieve get_test req&quot; &lt;&lt; std::endl;\t\tint i = 0;\t\tfor (auto&amp; elem : connection-&gt;_get_params) &#123;\t\t\ti++;\t\t\tboost::beast::ostream(connection-&gt;_response.body()) &lt;&lt; &quot;parm&quot; &lt;&lt; i &lt;&lt; &quot;key is &quot; &lt;&lt; elem.first;\t\t\tboost::beast::ostream(connection-&gt;_response.body()) &lt;&lt; &quot;,&quot; &lt;&lt; &quot;value is &quot; &lt;&lt; elem.second &lt;&lt; std::endl;\t\t&#125;\t\t&#125;);\t//处理POST请求&#125;\n\n我们在构造函数里面实现&#x2F;get_test路由的回调函数\n实现RegsiterGet()函数用来接收客户端的信息\nvoid LogicSystem::RegsiterGet(std::string url, HttpHandler handler) &#123;\t_get_handler.insert(std::make_pair(url, handler));&#125;\n\n在RegsiterGet()函数里面添加新的key和value\n接下来实现HandleGet()函数\nbool LogicSystem::HandleGet(std::string url, std::shared_ptr&lt;HttpConnectionMgr&gt; connection) &#123;\tif (_get_handler.find(url) == _get_handler.end()) &#123;\t\treturn false;\t&#125;\t_get_handler[url](connection);\treturn true;&#125;\n\nLogicSystem类的函数已经基本实现，接下来实现HttpConnectionMgr类里面的WriteResponse()函数与CheckDeadLine()函数\nWriteResponse()函数的实现\nvoid HttpConnectionMgr::WriteResponse() &#123;\tauto self = shared_from_this();\t_response.content_length(_response.body().size());\tboost::beast::http::async_write(_socket, _response, [self](boost::beast::error_code ec, std::size_t) &#123;\t\tif (ec) &#123;\t\t\tself-&gt;_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);\t\t\tself-&gt;_deadline.cancel();\t\t&#125;\t\t&#125;);&#125;\n\n因为http是短链接，所以发送完数据后不需要再监听对方链接，直接断开发送端即可。\nhttp处理请求需要有一个时间约束，发送的数据包不能超时。所以在发送时我们启动一个定时器，收到发送的回调后取消定时器。\n这是检测超时函数CheckDeadLine()的实现\nvoid HttpConnectionMgr::CheckDeadLine() &#123;\tauto self = shared_from_this();\t_deadline.async_wait([self](boost::beast::error_code ec) &#123;\t\tif (!ec) &#123;\t\t\tself-&gt;_socket.close(ec);\t\t&#125;\t\t&#125;);&#125;\n实现主函数main我们在主函数中初始化上下文iocontext以及启动信号监听ctr-c退出事件， 并且启动iocontext服务\nint main()&#123;    try &#123;        unsigned short port = static_cast&lt;unsigned short&gt;(8080);        boost::asio::io_context ioc&#123; 1 &#125;;        boost::asio::signal_set signals(ioc, SIGINT, SIGTERM);        signals.async_wait([&amp;ioc](const boost::system::error_code&amp; ec, int signal_number) &#123;            if (ec) &#123;                return;            &#125;            ioc.stop();            &#125;);        std::make_shared&lt;Server&gt;(ioc, port)-&gt;Start();        ioc.run();    &#125;    catch (std::exception const&amp; ec) &#123;        std::cout &lt;&lt; &quot;Exception is: &quot; &lt;&lt; ec.what() &lt;&lt; std::endl;        return EXIT_FAILURE;    &#125;    return 0;&#125;\n\n实现GET请求实现GET请求的时候我们需要先解码，分析数据，再编码发送给客户端，为了实现GET请求解码编码的函数，我们需要10进制char转换为16进制或者将16进制的char转化为10进制\n10进制的char转化为16进制\nunsigned char ToHex(unsigned short x) &#123;\treturn x &gt; 9 ? x + 55 : x + 48;&#125;\n\n16进制的char转化为10进制\nunsigned char FromHex(unsigned short x) &#123;\tunsigned char y = 0;\tif (x &gt; &#x27;A&#x27; &amp;&amp; x &lt; &#x27;Z&#x27;) &#123;\t\ty = x - &#x27;A&#x27; + 10;\t&#125;\telse if (x &gt; &#x27;a&#x27; &amp;&amp; x &lt; &#x27;z&#x27;) &#123;\t\ty = x - &#x27;a&#x27; + 10;\t&#125;\telse if (x &gt; &#x27;0&#x27; &amp;&amp; x &lt; &#x27;9&#x27;) &#123;\t\ty = x - &#x27;0&#x27;;\t&#125;\telse &#123;\t\tassert(0);\t&#125;\treturn y;&#125;\n\n编码函数\nstd::string UrlEncode(const std::string&amp; str) &#123;\tstd::string strTemp = &quot;&quot;;\tstd::size_t length = str.length();\tfor (int i = 0;i &lt; length;i++) &#123;\t\tif (isalnum((unsigned short)str[i]) ||\t\t\t(str[i] == &#x27;-&#x27;) ||\t\t\t(str[i] == &#x27;_&#x27;) ||\t\t\t(str[i] == &#x27;.&#x27;) ||\t\t\t(str[i] == &#x27;~&#x27;)) \t\t&#123;\t\t\tstrTemp += str[i];\t\t&#125;\t\telse if (str[i] == &#x27; &#x27;) &#123;\t\t\tstrTemp += &quot;+&quot;;\t\t&#125;\t\telse &#123;\t\t\tstrTemp += &quot;%&quot;;\t\t\tstrTemp += ToHex(str[i] &gt;&gt; 4);\t\t\tstrTemp += ToHex(str[i] &amp; 0x0F);\t\t&#125;\t&#125;\treturn strTemp;&#125;\n\n首先判断str[i]是否为数字或者一些简单的下划线等字符，如果是直接拼接就可以，之后再判断str[i]是否为空，如果为空则拼上一个‘+’；剩下的都是特殊字符。需要将特殊字符转化为’%’和两个十六进制字符拼接；先拼接“%“字符，，再将字符的高四位拼接到strTemp上，最后将低四位拼接到strTemp上。\n解码函数\nstd::string UrlDecode(const std::string&amp; str) &#123;\tstd::string strTemp = &quot;&quot;;\tstd::size_t length = str.length();\tfor (int i = 0;i &lt; length;i++) &#123;\t\tif (str[i] == &#x27;+&#x27;) &#123;\t\t\tstrTemp += &quot; &quot;;\t\t&#125;\t\telse if (str[i] == &#x27;%&#x27;) &#123;\t\t\tassert(i + 2 &lt; length);\t\t\tunsigned char high = FromHex((unsigned char)str[++i]);\t\t\tunsigned char low = FromHex((unsigned char)str[++i]);\t\t\tstrTemp += high * 16 + low;\t\t&#125;\t\telse &#123;\t\t\tstrTemp += str[i];\t\t&#125;\t&#125;\treturn strTemp;&#125;\n\n解码函数的编写与编码函数原理一样，就不写注释了\n先在HttpConnectionMgr类里添加两个私有成员，_get_url用来存储HTTP的url信息,_get_params用来存储url和相关信息，url就是_get_params的key值\nstd::string _get_url;std::map&lt;std::string, std::string&gt; _get_params;\n\n接下来添加解析URL的函数\nvoid HttpConnectionMgr::PreParseGetParam() &#123;\tauto uri = _request.target();\tauto query_pos = uri.find(&#x27;?&#x27;);\tif (query_pos == std::string::npos) &#123;\t\t_get_url = uri;\t\treturn;\t&#125;\t_get_url = uri.substr(0, query_pos);\tstd::string query_string = uri.substr(query_pos + 1);\tstd::string key;\tstd::string value;\tstd::size_t pos = 0;\twhile ((pos = query_string.find(&#x27;&amp;&#x27;)) != std::string::npos) &#123;\t\tauto pair = query_string.substr(0, pos);\t\tstd::size_t ep_pos = pair.find(&#x27;=&#x27;);\t\tif (ep_pos != std::string::npos) &#123;\t\t\tkey = UrlDecode(pair.substr(0, ep_pos));\t\t\tvalue = UrlDecode(pair.substr(ep_pos + 1));\t\t\t_get_params[key] = value;\t\t&#125;\t\tquery_string.erase(0, pos + 1);\t&#125;    //还有一段信息未解析，解析最后一段数据\tif (!query_string.empty()) &#123;\t\tstd::size_t ep_pos = query_string.find(&#x27;=&#x27;);\t\tif (ep_pos != std::string::npos) &#123;\t\t\tkey = UrlDecode(query_string.substr(0, ep_pos));\t\t\tvalue = UrlDecode(query_string.substr(ep_pos + 1));\t\t\t_get_params[key] = value;\t\t&#125;\t&#125;&#125;\n\n在HandleRequest()函数里面添加解析URL的函数\nvoid HttpConnectionMgr::HandleRequest() &#123;\t//...\t//发送的是GET请求\tif (_request.method() == boost::beast::http::verb::get) &#123;\t\tPreParseGetParam();\t\tbool sucess = LogicSystem::GetInstance()-&gt;HandleGet(_get_url, shared_from_this());\t//...\t&#125;\t//发送的是POST请求&#125;\n实现POST请求解析POST请求与解析GET请求的流程基本一致，首先在LogicSystem类里添加处理函数\nbool HandlePost(std::string url, std::shared_ptr&lt;HttpConnectionMgr&gt; connection);void RegsiterPost(std::string url, HttpHandler handler);\n\n然后实现HandlePost()和RegsiterPost()这两个具体的函数\nbool LogicSystem::HandlePost(std::string url, std::shared_ptr&lt;HttpConnectionMgr&gt; connection) &#123;\tif (_post_handler.find(url) == _post_handler.end()) &#123;\t\treturn false;\t&#125;\t_post_handler[url](connection);&#125;void LogicSystem::RegsiterPost(std::string url, HttpHandler handler) &#123;\t_post_handler.insert(std::make_pair(url, handler));&#125;\n\n在LogicSystem类的构造函数添加处理POST请求\n//处理POST请求RegsiterPost(&quot;/get_varifycode&quot;, [](std::shared_ptr&lt;HttpConnectionMgr&gt; connection) &#123;\tauto body_str = boost::beast::buffers_to_string(connection-&gt;_request.body().data());\tstd::cout &lt;&lt; &quot;recieve data body is: &quot; &lt;&lt; body_str &lt;&lt; std::endl;\tconnection-&gt;_response.set(boost::beast::http::field::content_type, &quot;test/json&quot;);\tJson::Value root;\tJson::Value src_root;\tJson::Reader reader;\tbool parse_sucess = reader.parse(body_str, src_root);\tif (!parse_sucess) &#123;\t\tstd::cout &lt;&lt; &quot;Failed to parse json data!&quot; &lt;&lt; std::endl;\t\troot[&quot;error&quot;] = ErrorCodes::Error_Json;\t\tstd::string jsonstr = root.toStyledString();\t\tboost::beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr;\t\treturn true;\t&#125;\tauto email = src_root[&quot;email&quot;].asString();\tstd::cout &lt;&lt; &quot;email is: &quot; &lt;&lt; email &lt;&lt; std::endl;\troot[&quot;error&quot;] = 0;\troot[&quot;email&quot;] = src_root[&quot;email&quot;];\tstd::string jsonstr = root.toStyledString();\tboost::beast::ostream(connection-&gt;_response.body()) &lt;&lt; jsonstr;\treturn true;\t&#125;);\n\n在HttpConnectionMgr类里的HandleRequest() 函数里面添加处理POST请求\nvoid HttpConnectionMgr::HandleRequest() &#123;\t//...省略\t//发送的是POST请求\tif (_request.method() == boost::beast::http::verb::post) &#123;\t\tPreParseGetParam();\t\tbool sucess = LogicSystem::GetInstance()-&gt;HandlePost(_get_url, shared_from_this());\t\tif (sucess) &#123;\t\t\t_response.result(boost::beast::http::status::ok);\t\t\t_response.set(boost::beast::http::field::server, &quot;GateServer&quot;);\t\t\tWriteResponse();\t\t\treturn;\t\t&#125;\t\telse &#123;\t\t\t_response.result(boost::beast::http::status::not_found);\t\t\t_response.set(boost::beast::http::field::content_type, &quot;text/plain&quot;);\t\t\tboost::beast::ostream(_response.body()) &lt;&lt; &quot;url not found\\r\\n&quot;;\t\t\tWriteResponse();\t\t\treturn;\t\t&#125;\t&#125;&#125;\n\n客户端增加POST逻辑之前我们已经在Qt客户端实现了POST请求，现在我们实现发送HTTP的POST请求\n找到RegisterDialog类的on_acquire_pushbutton_clicked()函数，添加如下代码\nvoid RegisterDialog::on_acquire_pushbutton_clicked()&#123;    //...省略    if(match)&#123;        //发送Http请求发送验证码        QJsonObject json_obj;        json_obj[&quot;email&quot;] = email;        HttpMgr::GetInstance()-&gt;PostHttpRequest( ReqID::ID_GET_VARIFY_CODE, Modules::REGISTER_MOD, QUrl(gate_url_prefix + &quot;/get_varifycode&quot;), json_obj);    &#125;    else&#123;        ShowTips(&quot;邮箱地址不正确&quot;, false);    &#125;&#125;\n\n当服务器不启动，客户端输入邮箱，点击获取验证码，客户端会收到网络连接失败的提示\n\n启动服务器后，再次获取验证码，就显示正确提示了，而且客户端输出了服务器回传的邮箱地址email is “&#49;&#x33;&#x30;&#48;&#x31;&#54;&#x34;&#51;&#51;&#x36;&#64;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;“，界面也刷新为正确显示\n\n客户端添加ini文件在代码所在的根目录下新建一个config.ini文件, 内部添加配置\n[GateServer]host=localhostport=8080\n\n点击项目右键选择添加现有文件，选中config.ini即可\n打开项目的pro文件，在最下面添加以下代码\nwin32:CONFIG(release, debug | release)&#123;    #指定要拷贝的文件目录为工程目录下release目录下的所有dll、lib文件，例如工程目录在D:\\QT\\Test    TargetConfig = $$&#123;PWD&#125;/config.ini    #将输入目录中的&quot;/&quot;替换为&quot;\\&quot;    TargetConfig = $$replace(TargetConfig, /, \\\\)    #将输出目录中的&quot;/&quot;替换为&quot;\\&quot;    OutputDir =  $$&#123;OUT_PWD&#125;/$$&#123;DESTDIR&#125;    OutputDir = $$replace(OutputDir, /, \\\\)    //执行copy命令    QMAKE_POST_LINK += copy /Y \\&quot;$$TargetConfig\\&quot; \\&quot;$$OutputDir\\&quot;&#125;\n\n因为我们的程序最终会输出的bin目录，所以在pro中添加拷贝脚本将配置也拷贝到bin目录\n在globle.h中添加声明\nextern QString gate_url_prefix;\n\n在globle.cpp里面添加定义\nQString gate_url_prefix = &quot;&quot;;\n\n在main函数里面添加解析配置的逻辑\nQString app_path = QCoreApplication::applicationDirPath();qDebug()&lt;&lt;&quot;app_path is: &quot;&lt;&lt;app_path;QString file_name = &quot;config.ini&quot;;QString config_path = QDir::toNativeSeparators(app_path + QDir::separator() + file_name);qDebug()&lt;&lt;&quot;config_path is: &quot;&lt;&lt;config_path;QSettings settings(config_path, QSettings::IniFormat);QString gate_host = settings.value(&quot;GateServer/host&quot;).toString();QString gate_port = settings.value(&quot;GateServer/port&quot;).toString();qDebug()&lt;&lt;&quot;host is: &quot;&lt;&lt;gate_host;gate_url_prefix = &quot;http://&quot; + gate_host + &quot;:&quot; + gate_port;\n\n将RegisterDialog类的on_acquire_pushbutton_clicked()函数里面的发送请求改为\nHttpMgr::GetInstance()-&gt;PostHttpRequest( ReqID::ID_GET_VARIFY_CODE, Modules::REGISTER_MOD, QUrl(gate_url_prefix + &quot;/get_varifycode&quot;), json_obj);\n\n再次测试仍旧可以收到服务器回馈的http包。\n这么做的好处就是客户端增加了配置，而且以后修改参数也方便。\n","categories":["C++网络聊天项目"],"tags":["软件"]},{"title":"extern关键字","url":"/2024/12/28/extern%E5%85%B3%E9%94%AE%E5%AD%97/","content":"在我们编写代码的过程中，可能会遇到重定义问题\n重定义问题首先创建一个global.h文件，在global.h文件中定义两个变量global_age和global_name\n#pragma once#include &lt;iostream&gt;int global_age = 10;std::string global_name = &quot;qsct&quot;;\n\n然后我们在主函数中使用这两个变量\n#include &lt;iostream&gt;#include &quot;global.h&quot;int main()&#123;    std::cout &lt;&lt; &quot;global name is: &quot; &lt;&lt; global_name &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;global age is: &quot; &lt;&lt; global_age &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Hello World!\\n&quot;;&#125;\n\n在与运行的过程中就会出现如下错误\n\nextern关键字在C++中，extern关键字用于声明一个变量或函数是在另一个文件或同一个文件的其他位置定义的。这主要用于处理全局变量或函数声明，确保在多个源文件中可以正确的链接到这些全局变量或函数的定义\n重定义问题解决办法在global.h修改变量global_age和global_name\n#pragma once#include &lt;iostream&gt;extern int global_age;extern std::string global_name;\n\n然后再global.cpp里面定义变量global_age和global_name\n#include &quot;global.h&quot;int global_age = 10;std::string global_name = &quot;qsct&quot;;\n\n再次进行编译，就可以正常的运行程序了\n\n","categories":["C++"],"tags":["软件"]}]