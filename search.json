[{"title":"C++的存储空间和编译过程","url":"/2024/11/18/C-%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","content":"存储空间在C++中，内存存储通常分为以下五个区域：\n1、代码区：\n存储程序的执行代码，这部分区域是共享的，只读的，并且在程序执行期间并不会更改。例如当你编辑一个C++程序时，所有的函数定义，控制结构等都会被变成机器指令，然后存到代码区里面\n\n2、全局、静态存储区\n存储全局变量和静态变量的内存区域，这些变量在整个程序的执行期间都会存在，只不过他们的可见性与生命周期取决于声明它们的作用域\n\n3、栈区\n存储局部变量，函数参数，返回地址等的内存区域，它的特点是先进后出用于存储函数调用和自然变量\n\n4、堆区\n在C++中，我们程序员通过动态内存分配函数（new函数和malloc函数）分配的内存空间，在开辟之后必须手动释放，以免出现内存泄漏和野指针的问题（内存泄漏是指开辟内存没有手动回收，野指针是指使用已经被手动回收的指针）\n\n5、常量区\n常量区一般是存储字符串常量和const修饰的数据，它代表这部分数据仅仅是可读的，程序员并不能对它们进行修改\n\n编译过程 C++程序的编译是一个相对复杂并且有序的过程，它涉及到将高级语言（C++）转换为机器可以识别的低级指令。在这个过程中，通常会生成.i(预处理文件)、.s(汇编文件)、.o(目标文件或对象文件)。以下是这个过程的详细解释\n1、预处理\n输入：C++源代码\n处理：预处理器读取源代码文件，并对其进行宏展开、条件编译、文件包含等操作\n输出：生成处理后的文件，通常带有.i后缀\n\n2、编译\n输入：预处理后的文件\n处理：编辑器将预处理后的源代码或文件转为汇编语言代码。这个步骤是编译的核心，编译器需要执行词法分析、语法分析、语义分析、中间代码生成、代码优化等任务\n输出：生成汇编文件，通常带有.s后缀\n\n3、汇编\n输入：汇编文件\n处理：汇编器将汇编语言代码转化为机器代码(只有0和1组成的文件)但是这些指令仍然是针对特定架构的，尚未被来凝结的可执行文件\n输出：生成目标文件，通常带有.o、.obj、.out等后缀\n\n4、链接\n输入：1个或多个目标文件以及可能需要的库文件\n处理：在这个过程中，链接器将目标文件和库文件合并成一个可执行文件或库文件。在这个过程中，链接器会解决外部符号引用(即函数和变量的调用)，并将它们链接到正确的地址\n输出： 可执行文件.exe\n\n","categories":["C++"],"tags":["软件"]},{"title":"使用Hexo安装博客，发现npm淘宝镜像源不生效的问题","url":"/2024/11/17/%E4%BD%BF%E7%94%A8Hexo%E5%AE%89%E8%A3%85%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%8F%91%E7%8E%B0npm%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%E6%BA%90%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/","content":"近期使用Hexo框架搭建博客的时候，发现使用npm下载淘宝镜像源总是失败，最后发现是淘宝更换了镜像源\n具体原因是：原NPM淘宝域名证书过期提醒：npm.taobao.org和registry.npm.taobao.org旧域名于2021年官方公告域名更换事件，已于2022年05月31日零时起停止服务，域名HTTPS证书于2024年1月22日正式到期，不可再用。若有前端工程仍使用旧域名镜像源，会导致编译失败或超时，影响功能迭代上线。为避免受到严重影响，请尽快将代码或流水线中配置的镜像源修改为以下任意源：x-repo(推荐)：http://x-repo.haier.net/repository/npm-public/；淘宝的新域名：https://registry.npmmirror.com/\n简单来说就是淘宝更换镜像源了。\n解决方案：使用npm执行以下命令即可\nnpm config set registry https://registry.npmmirror.com","categories":["搭建博客"],"tags":["软件"]},{"title":"使用Hexo更换主题后出现问题的解决方法","url":"/2024/11/17/%E4%BD%BF%E7%94%A8Hexo%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E5%90%8E%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"前段时间使用Hexo成功搭建了网站，后来更改Hexo主题后重新启动了服务器，但是界面却出现了以下字符：\nextends includes/layout.pug block content include includes/recent-posts.pug include includes/partial\n具体原因后来才发现更改主题还需要使用npm安装以下两个插件才行： hexo-renderer-pug和hexo-renderer-stylus\n解决方案：我们使用npm执行以下命令即可\nnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\n","categories":["搭建博客"],"tags":["软件"]},{"title":"使用QT创建聊天室客户端","url":"/2024/11/20/%E4%BD%BF%E7%94%A8QT%E5%88%9B%E5%BB%BA%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%AE%A2%E6%88%B7%E7%AB%AF/","content":"Note： 此项目原博客地址https://llfc.club/category?catid=225RaiVNI8pFDD5L4m807g7ZwmF#!aid/2eIZbBf2pkVGQG1oPdRLDtTDLo0\n1、创建项目首先使用QT软件创建Qt Widgets Application,生成的基类使用QMainWindow\n\n321\n2、添加资源文件并更换图标首先将准备的图片文件添加到res文件夹下，然后将res文件夹放下项目根目录下；然后在Qt软件中点中项目名称，选择添加新文件，选择Qt Resource Files,添加Qt的资源文件，名字设为rc，添加成功后右键rc.qrc选择添加现有文件，然后选中res文件夹下的所有图片，这样res文件夹下的所有图片资源都导入到项目里面了。\n然后将QMainWindow的界面长宽改为300x500\n\n之后修改项目左上角的图标，在QMainWindow的界面找到windowIcon，选择添加res文件下的ICNO.ico\n\n修改项目左上面的标题，将MainWindow修改为Chat,在QMainWindow的构造函数添加以下代码即可\nsetWindowTitle(&quot;Chat&quot;);\n3、添加登录页面右键项目名称并选择添加新项目，点击Qt设计师界面类\n\n选择Dialog Without Buttons\n\n将名字起为LoginDialog,创建完成后点击ui界面并将ui界面修改为以下布局：\n\n在QMainWindow的类里添加LoginDialog的指针成员，并在QMainWindow构造函数里面设置为中心部件\n_login_dialog = new LoginInDialog();setCentralWidget(_login_dialog);_login_dialog-&gt;show();\n4、添加样式表在项目的根目录下创建一个名为style的文件夹，打开style文件夹建立一个.text文件，将这个.text文件名称改为stylesheet.qss，然后右键点击Qt项目中的rc.qrc，选择添加现有文件，选择刚刚创建的style文件夹即可，这样stylesheet.qss就被导入到项目中了\n打开stylesheet.qss并写下如下代码\nQDialog#LoginInDialog&#123;  background-color:rgb(255,255,255)&#125;\n这样LoginInDialog界面的背景就被美化成白色了\n然后在主函数main里面添加以下代码用来启动qss文件\nint main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    QFile qss(&quot;:/style/stylesheet.qss&quot;);    if(qss.open(QFile::ReadOnly))&#123;        qDebug(&quot;open success!&quot;);        QString style = QLatin1String(qss.readAll());        a.setStyleSheet(style);        qss.close();    &#125;else&#123;        qDebug(&quot;open failed!&quot;);    &#125;    MainWindow w;    w.show();    return a.exec();&#125;\n5、添加注册页面跟添加登录页面的方式添加注册页面，将名字设置为RegisterDialog，添加完成之后打开注册页面的ui，将注册页面的ui修改成以下画面\n\n然后在注册页面的构造函数里面将code_lineedit和confirm_lineedit置为密码模式\nui-&gt;code_lineedit-&gt;setEchoMode(QLineEdit::Password);ui-&gt;confirm_lineedit-&gt;setEchoMode(QLineEdit::Password);\n\n我们在qss里面添加tips的样式，正确状态下tips里面的文字显示为绿色，错误状态下tips的文字显示为红色\n#tips[state = &#x27;normal&#x27;]&#123;  color: green;&#125;#tips[state = &#x27;error&#x27;]&#123;  color: red;&#125;\n\n然后我们来实现tips的刷新功能，这个刷新功能函数repolish打算做成全局函数来实现,因此我们添加global.cpp和global.h文件\nglobal.h文件的声明：\n#ifndef GLOBAL_H#define GLOBAL_H#include &lt;QWidget&gt;#include &lt;functional&gt;#include &quot;QStyle&quot;extern std::function&lt;void(QWidget*)&gt; repolish;#endif // GLOBAL_H\n\nglobal.cpp文件里repolish函数的实现：\nstd::function&lt;void(QWidget*)&gt; repolish=[](QWidget* w)&#123;    w-&gt;style()-&gt;unpolish(w);    w-&gt;style()-&gt;polish(w);&#125;;\n\n在RegisterDialog的构造函数里面添加tips的样式设置\nui-&gt;tips-&gt;setProperty(&quot;state&quot;, &quot;normal&quot;);repolish(ui-&gt;tips);\n\n接下来实现获取验证码的逻辑，在RegisterDialog.ui里面右键点击获取按钮，选择转到槽，在槽函数里面写下如下代码\n//使用正则表达式验证邮箱地址auto email=ui-&gt;email_lineedit-&gt;text();//邮箱地址的正则表达式QRegularExpression regex(R&quot;((\\w+)(\\.|_)?(\\w*)@(\\w+)(\\.(\\w+))+)&quot;);bool match = regex.match(email).hasMatch();if(match)&#123;    ShowTips(&quot;邮箱地址正确&quot;, true);    //发送Http请求发送验证码&#125;else&#123;    ShowTips(&quot;邮箱地址不正确&quot;, false);&#125;\n\n下面实现ShowTips函数，这个函数用来显示tips的文字和状态\nvoid RegisterDialog::ShowTips(QString str, bool b_ok)&#123;    if(b_ok)&#123;        ui-&gt;tips-&gt;setProperty(&quot;state&quot;, &quot;normal&quot;);    &#125;    else&#123;        ui-&gt;tips-&gt;setProperty(&quot;state&quot;, &quot;error&quot;);    &#125;    ui-&gt;tips-&gt;setText(str);    repolish(ui-&gt;tips);&#125;\n\n6、添加单例类我们编写网络通讯需要确保一个类只生成一个实例，所以我们编写一个单例模板类，之后的网络通讯类都继承这个单例类\n#include &lt;mutex&gt;#include &lt;memory&gt;#include &lt;iostream&gt;#include &quot;QDebug&quot;template &lt;typename T&gt;class SingleTon&#123;protected:   SingleTon() = default;   SingleTon(const SingleTon&lt;T&gt;&amp;) = delete;   SingleTon&amp; operator = (const SingleTon&lt;T&gt;&amp;) = delete;   static std::shared_ptr&lt;T&gt; _instance;public:   static std::shared_ptr&lt;T&gt; GetInstance()&#123;       static std::once_flag _flag;       std::call_once(_flag,[&amp;]()&#123;           _instance = std::shared_ptr&lt;T&gt;(new T);       &#125;);       return _instance;   &#125;   void PrintAdress()&#123;       std::cout&lt;&lt; _instance.get() &lt;&lt;std::endl;   &#125;&#125;;template &lt;typename T&gt;std::shared_ptr&lt;T&gt; SingleTon&lt;T&gt;::_instance = nullptr;\n\n7、添加Http管理类Http管理类主要用于管理HTTP接收发送等请求，首先我们需要在pro文件里面添加网络库\nQT  +=  core gui network\n\n在global.h里面添加一些Http管理类用到的头文件\n#include &lt;QByteArray&gt;#include &lt;QNetworkRequest&gt;#include &lt;QNetworkReply&gt;#include &lt;qDebug&gt;#include &lt;QString&gt;#include &lt;QUrl&gt;#include &lt;QObject&gt;#include &lt;QNetworkAccessManager&gt;#include &lt;memory&gt;#include &lt;QJsonObject&gt;#include &lt;QJsonDocument&gt;#include &lt;QMap&gt;\n\n添加httpMgr.cpp和httpMgr.h，httpMgr.h头文件如下\n#ifndef HTTPMGR_H#define HTTPMGR_H#include &quot;singleton.h&quot;#include &quot;global.h&quot;class HttpMgr: public QObject,public SingleTon&lt;HttpMgr&gt;, public std::enable_shared_from_this&lt;HttpMgr&gt;&#123;    Q_OBJECT    friend class SingleTon&lt;HttpMgr&gt;;public:    ~HttpMgr();    void PostHttpRequest(ReqID id, Modules modules, QUrl url, QJsonObject json);signals:    void SignalHttpFinished(ReqID id, Modules modules, ErrorCode ec_code, QString res);    //    void SignalRegisterFinished(ReqID id, ErrorCode ec_code, QString res);private slots:    void SlotHttpFished(ReqID id, Modules modules, ErrorCode ec_code, QString res);private:    HttpMgr();    QNetworkAccessManager  _manager;&#125;;#endif // HTTPMGR_H\n\nPostHttpRequest函数用来接收HTTP发送过来的消息，参数id和modules用来区分HTTP信息的类型，url是请求的地址，json是请求的数据\n我们在global.h里面定义ReqID枚举类型\nenum ReqID&#123;    ID_GET_VARIFY_CODE = 1001,    ID_REGISTER_USER = 1002&#125;\n\nReqID有两个作用，一个作用是定位接收的是哪一部份数据；第二个作用是存储数据的key值使用，ReqID&#x3D;1001时，说明此时处于注册状态，我们需要将ReqID和验证码存入到map里，ReqID就作为验证码的key值使用；同理，当ReqID&#x3D;1002时，ReqID就作为密码的key值所使用\n在global.h里面定义ErrorCode\nenum ErrorCode&#123;    SUCESS = 0,    ERROR_JSON = 1,    ERROR_NETWORK = 2&#125;;\n\nErrorCode是错误的类型，用于帮助定位项目运行过程中在哪一部分出现问题\n在global.h里面定义Modules\nenum Modules&#123;    REGISTER_MOD = 0,&#125;;\n\nModules也是用来定位接收的是哪一部分数据，用来说明项目此时处于的状态，目前只将注册状态设为0，但之后还会有登录状态和忘记密码的状态\n在PostHttpRequest函数里面首先发送Post请求然后收到回复并解析，无论解析的数据如何都会发送SignalHttpFinished信号，然后数据传输到槽函数SlotHttpFished里面，槽函数SlotHttpFished再次发送信号SignalRegisterFinished，接收信号的槽函数SlotRegisterFinished被定义于RegisterDialog类里面\n简单来讲，RegisterDialog类里面的函数调用HttpMgr类的函数发送HTTP信息，HttpMgr类的函数将接收的信息传送回RegisterDialog类里面的函数，数据的解析是在RegisterDialog类里进行，HttpMgr类只负责数据的发送和接收\nPostHttpRequest函数的实现如下\nvoid HttpMgr::PostHttpRequest(ReqID id, Modules modules, QUrl url, QJsonObject json)&#123;    QByteArray data = QJsonDocument(json).toJson();    QNetworkRequest request(url);    request.setHeader(QNetworkRequest::ContentTypeHeader, &quot;application/json&quot;);    request.setHeader(QNetworkRequest::ContentLengthHeader,QByteArray::number(data.length()));    auto self = shared_from_this();    //发送reques数据    QNetworkReply* reply =  _manager.post(request, data);    //接受reply数据    QObject::connect(reply, &amp;QNetworkReply::finished, [reply,  self, id, modules]()&#123;        //发送错误        if(reply-&gt;error() != QNetworkReply::NoError)&#123;            qDebug()&lt;&lt;reply-&gt;errorString();            //发送信号说明数据传输错误            emit self-&gt;SignalHttpFinished(id, modules, ErrorCode::ERROR_NETWORK, &quot;&quot;);            reply-&gt;deleteLater();            return;        &#125;        //发送信号说明数据已经传输完成        QString res = reply-&gt;readAll();        emit self-&gt;SignalHttpFinished(id, modules, ErrorCode::SUCESS, res);        reply-&gt;deleteLater();        return;    &#125;);&#125;\n\n槽函数SlotHttpFished的实现\nvoid HttpMgr::SlotHttpFished(ReqID id, Modules modules, ErrorCode ec_code, QString res)&#123;    if(modules == Modules::REGISTER_MOD)&#123;        emit SignalRegisterFinished(id, ec_code, res);    &#125;&#125;\n\n在HttpMgr的构造函数里面将信号SignalHttpFinished与槽函数SlotHttpFished连接\nconnect(this, &amp;HttpMgr::SignalHttpFinished, this, &amp;HttpMgr::SlotHttpFished);\n\n在RegisterDialog的构造函数里面将信号SignalRegisterFinished和槽函数SlotRegisterFinished连接\nconnect(HttpMgr::GetInstance().get(), &amp;HttpMgr::SignalRegisterFinished, this, &amp;RegisterDialog::SlotRegisterFinished);\n\n然后实现槽函数SlotRegisterFinished\nvoid RegisterDialog::SlotRegisterFinished(ReqID id, ErrorCode ec_code, QString res)&#123;    if(ec_code != ErrorCode::SUCESS)&#123;        ShowTips(&quot;网络请求错误&quot;, false);        return;    &#125;    //接收数据正常    else&#123;        QJsonDocument jsonDoc = QJsonDocument::fromJson(res.toUtf8());        if(jsonDoc.isNull())&#123;            ShowTips(&quot;JSON解析错误&quot;, false);            return;        &#125;        if(jsonDoc.isObject())&#123;            ShowTips(&quot;JSON解析错误&quot;, false);            return;        &#125;        //处理相应请求        _handlers[id](jsonDoc.object());        return;    &#125;&#125;\n\n8、添加注册信息处理我们需要对注册的信息进行处理，在RegisterDialog类的私有成员进行声明\n// _handlers处理注册ID和验证码信息QMap&lt;ReqID, std::function&lt;void(const QJsonObject&amp;)&gt;&gt; _handlers;\n\n对于注册信息的定义与声明\nvoid RegisterDialog::InitHttpHandlers()&#123;    _handlers.insert(ReqID::ID_GET_VARIFY_CODE, [this](QJsonObject jsonobj)&#123;        int error = jsonobj[&quot;error&quot;].toInt();        if(error != ErrorCode::SUCESS)&#123;            ShowTips(&quot;参数错误&quot;, false);            true;        &#125;        auto email = jsonobj[&quot;email&quot;].toString();        ShowTips(&quot;验证码已经发送到邮箱,请注意查收&quot;, true);    &#125;);&#125;\n\n在槽函数SlotRegisterFinished里面添加根据id调用函数处理对应逻辑\nvoid RegisterDialog::SlotRegisterFinished(ReqID id, ErrorCode ec_code, QString res)&#123;    if(ec_code != ErrorCode::SUCESS)&#123;        ShowTips(&quot;网络请求错误&quot;, false);        return;    &#125;    //接收数据正常    else&#123;        //前面逻辑省略...        //处理相应请求        _handlers[id](jsonDoc.object());        return;    &#125;&#125;"},{"title":"使用markdown添加图片不显示问题的解决方法","url":"/2024/11/23/%E4%BD%BF%E7%94%A8markdown%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"问题描述在这几天，我尝试使用markdown添加图片，但是图片却显示不出来。\n这是我当时使用markdown写下的添加图片的格式：\n![Wide_And_Length](/image/使用QT创建聊天室客户端/QMainWindow长宽大小.png)\n这是当时预览的图片显示\n\n我的存储图片的文件夹跟md文件存储在同一目录下，如图所示\n\n然后我尝试了将图片的路径先返回到上一级的目录下，然后再添加图片路径，这时候在markdown文档预览的时候出现了图片，但是当我将文章发布到了GitHub之后却发现图片依旧显示不出来\n此时添加图片的格式\n![Wide_And_Length](../_posts/image/使用QT创建聊天室客户端/QMainWindow长宽大小.png)\n\nmarkdown文档预览效果\n打开博客实际效果&#x2F;&#x2F;图片四\n解决方法首先在博客仓库下选择添加新的文件\n\n然后选择添加新的分支\n\n将图片添加到这个分支里面\n\n右键点击图片选择复制图片地址，将地址复制到之前的图片路径上\n\n这样图片就能显示出来了\n参考文章https://www.jianshu.com/p/c7618a53454f\n","categories":["搭建博客"],"tags":["软件"]}]